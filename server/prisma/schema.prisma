generator client {
  provider = "prisma-client-js"
}
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
enum LeadType {
  sfr
  land
  multi
  other
}
model Organization {
  id            String   @id @default(cuid())
  name          String   @default("Demo Org")
  timezone      String   @default("America/New_York")
  marketProfile String   @default("metro_sfr") // metro_sfr | land | hybrid
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  leads         Lead[]
  documents     LegalDocument[]
}

model Lead {
  id           String   @id @default(cuid())
  orgId        String
  type         LeadType @default(sfr)
  address      String
  city         String
  state        String
  zip          String
  addressHash  String
  source        String?
  notes         String?
  homeownerName String?
  phoneNumber   String?
  ruralFlag     Boolean  @default(false)
  populationOk Boolean  @default(true)
  landSignals  Json?
  legalFlag    Boolean  @default(false)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Deal Milestones (Silver tier)
  underContractAt  DateTime?
  assignedAt       DateTime?
  escrowOpenedAt   DateTime?
  closedAt         DateTime?
  cancelledAt      DateTime?
  buyerName        String?
  assignmentFee    Decimal?  @db.Decimal(12, 2)

  org          Organization @relation(fields: [orgId], references: [id])
  contacts     LeadContact[]
  documents    LegalDocument[]

  @@index([orgId, type, ruralFlag])
  @@index([orgId, assignedAt])
  @@index([orgId, escrowOpenedAt])
  @@unique([orgId, addressHash], name: "orgId_addressHash")
}

model LeadContact {
  id           String   @id @default(cuid())
  leadId       String
  type         String   // "phone" | "email"
  value        String
  source       String?
  verifiedAt   DateTime?
  dncStatus    String?
  dncCheckedAt DateTime?

  lead         Lead     @relation(fields: [leadId], references: [id])
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([leadId, type])
}

model CalendarEvent {
  id        Int      @id @default(autoincrement())
  title     String
  date      DateTime
  startTime DateTime
  endTime   DateTime
  notes     String?
  urgency   String   // low / medium / critical
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userId    String

  // Status tracking
  status              String    @default("scheduled") // scheduled | completed | missed | cancelled
  completedAt         DateTime?
  missedAt            DateTime?
  cancelledAt         DateTime?
  reminderLeadMinutes Int       @default(480) // 8 hours = 480 minutes
  reminderSentAt      DateTime?

  // Canonical UTC timestamps (nullable for backward compatibility)
  startAt DateTime?
  endAt   DateTime?

  @@index([userId, date])
  @@index([date])
  @@index([userId, status, startAt])
  @@index([userId, status, endAt])
}

model Task {
  id          String    @id @default(cuid())
  orgId       String
  userId      String
  title       String
  description String?
  status      String    @default("pending") // 'pending' | 'completed' | 'cancelled'
  urgency     String    @default("medium") // 'low' | 'medium' | 'critical'
  dueAt       DateTime? @db.Timestamptz
  leadId      String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([orgId, userId, status])
  @@index([userId, dueAt])
  @@index([orgId, dueAt])
}

model User {
  id                      String           @id @default(cuid())
  
  // Firebase Auth fields (required by sessionService.ts)
  email                   String?          @unique
  firebase_uid            String?          @unique
  display_name            String?
  photo_url               String?
  
  // Plan & Status fields (required by sessionService.ts)
  plan                    String           @default("trial")
  status                  String           @default("active")
  trial_started_at        DateTime?
  trial_ends_at           DateTime?
  onboarding_complete     Boolean          @default(false)
  
  // Session management (required by sessionService.ts)
  session_version         Int              @default(1)
  
  // Lock state fields (required by sessionService.ts)
  lock_state              String           @default("none")
  disabled_at             DateTime?
  lock_reason             String?
  lock_expires_at         DateTime?
  
  // Stripe billing fields (existing)
  stripeCustomerId        String?          @unique
  stripeSubscriptionId    String?          @unique
  stripePriceId           String?
  billingStatus           BillingStatus?
  cancelAtPeriodEnd       Boolean?
  currentPeriodEnd        DateTime?
  subscriptionCancelledAt DateTime?
  lastStripeEventId       String?
  
  // Timestamps
  createdAt               DateTime         @default(now())
  updatedAt               DateTime         @updatedAt
  
  // Relations
  documents               LegalDocument[]

  @@index([stripeCustomerId])
  @@index([stripeSubscriptionId])
  @@index([billingStatus])
  @@index([currentPeriodEnd])
  @@index([firebase_uid])
}

model Deal {
  id        String           @id @default(cuid())
  documents LegalDocument[]
}

model LegalDocument {
  id        String           @id @default(cuid())
  orgId     String
  userId    String
  leadId    String?
  dealId    String?
  fileName  String
  filePath  String
  mimeType  String
  fileSize  Int
  category  DocumentCategory
  type      DocumentType?
  createdAt DateTime         @default(now())
  deal      Deal?            @relation(fields: [dealId], references: [id])
  lead      Lead?            @relation(fields: [leadId], references: [id])
  org       Organization     @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user      User             @relation(fields: [userId], references: [id])

  @@index([orgId, category])
}

enum DocumentCategory {
  CONTRACTS
  COMPLIANCE
  AGREEMENTS
  OTHER
}

enum DocumentType {
  PURCHASE_AGREEMENT
  ASSIGNMENT_CONTRACT
  OTHER
}

enum WaitlistTier {
  silver
  gold
}

enum BillingStatus {
  trialing
  active
  past_due
  canceled
  incomplete
  incomplete_expired
  unpaid
}

model Reminder {
  id             String    @id @default(cuid())
  orgId          String
  userId         String
  targetType     String    // 'calendar_event' | 'task' | etc
  targetId       String
  remindAt       DateTime  @db.Timestamptz
  reminderOffset Int       // minutes offset (e.g., -60 = 1 hour before)
  channel        String    // 'in_app' | 'email' | 'sms' (MVP: in_app only)
  timezone       String?   // IANA timezone string (e.g., "America/New_York")
  status         String    // 'scheduled' | 'pending' | 'sent' | 'delivered' | 'missed' | 'failed' | 'cancelled'
  idempotencyKey String    @unique
  sentAt         DateTime?
  deliveredAt    DateTime?
  failedAt       DateTime?
  errorMessage   String?
  retryCount     Int       @default(0)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@index([orgId, userId, status, remindAt])
  @@index([status, remindAt])
  @@unique([orgId, userId, targetType, targetId, reminderOffset, channel])
}

model WaitlistEntry {
  id        String       @id @default(cuid())
  email     String
  tier      WaitlistTier
  source    String?      // e.g. "pricing"
  ipHash    String?      // future: hashed IP, optional
  createdAt DateTime     @default(now())

  @@unique([email, tier], name: "waitlist_email_tier_unique")
  @@index([tier, createdAt], name: "waitlist_tier_createdAt_idx")
}

// Security telemetry (required by securityEvents.ts)
model SecurityEvent {
  id           BigInt    @id @default(autoincrement())
  event_type   String
  user_id      String?
  ip           String?
  user_agent   String?
  path         String?
  method       String?
  status_code  Int?
  reason       String?
  meta         Json?
  created_at   DateTime  @default(now())

  @@index([created_at])
  @@index([user_id, created_at])
  @@index([event_type, created_at])
  @@map("security_events")
}


